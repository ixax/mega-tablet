## 1. Авторизация (POST user/auth)

Не совсем понимаю как будет реализована, думаю это сейчас не так важно. Если говорим про OAuth, то на выходе получаем токен, который сохраняем в сессии пользователя и передаём во все запросы АПИ и при соединении к сокету.


## 2. Доступ к ручкам

При каждом запросе мы передаём OAuth-токен, бекенд сам решает отдавать данные или нет и если отдавать, то какие).

Если надо как-то ограничить действия над редактируемой/просматриваемой ноде - в каждом ответе передаётся доп поле `access`, в котором описаные все РАЗРЕШЕННЫЕ действия.


## 3. Слежение за изменениями (GET socket/NODE_ID)

Думаю Релизовывать будем через сокеты. При переключении между нодами (как в таблице, так и на холсте), при открытии параллельных нод, будем закрывать старое соединение socket.io и открывать новое, передавая id ноды.

Таким образом мы сможем получать команды только для текущей ноды и всех её поднод. Это удобно для изменения состояния таблицы, оповещении о новых конференциях, задачах и т.д.

Каждое событие имеет примерно следующую модель:

```
{
    nodeId: Number,
    action: {
        type: "enum. Например add_comment, add_polyline, update_polyline, start_conversation, etc.",
        timestamp: "unix-тайм создания записи в журнале",
        payload: "Аргументы события в строковом представлении. Клиент будет знать каждое событие и будет понмать что с ними делать. Кстати пожалуйста идея для расширения в дальнейшем - с сервера можно подгружать библиотеки событий, расширяя функционал"
    }
}
```


### 4. Внесение изменений (POST/PUT journal/NODE_ID)

Атомарные операции, ответа на которые от сервера в большинстве случаев не ожидаются.

Возможно кроме моментов создания полилиний, конференций.

Модель, передаваемая на сервер должна иметь такую же структуру, как и в пункте выше.


## 5. Создание нового сокета

При переключении между нодами или создании конференции необходимо закрывать все ненужные соединения и открывать новые.

Делается это элементарным GET-запросом, в отете которого приезжает id нового соединения и клиент запрашивает их.


## 6. Список нод (GET node/NODE_ID)

При открытии новой ноды отключаемся от сокета с предыдущей нодой, подключаемся к другому сокету.

Так же получаем список вложенных нод и аттрибутов (если это таблица), либо основные мета-данные, если это канва.


## 7. Список задач (GET node/NODE_ID/tasks)

Ручка, отдающая список задач по параметрам. Например:

Возможные параметры запроса:


```
limit
offset
sort - название поля, по которому сортируем
order - desc/asc (1/0) направление сортировки
q - поиск по автору, комментарию, etc.

```

* При открытии канвы, мы должны получить список задач (limit, offset)

* При скроллинге большого списка, зная текущий указатель (limit, offset)

* При изменении сортировки, нам надо передать поле, по которому сортируем (q)

* При сортировке (limit, offset, sort, order)


В ответ мы получаем массив задач в примерно таком виде:

Каждое событие имеет примерно следующую модель:

```
{
    nodeId: Number,
    tasks: [
        {
            taskId: Number,
            commands: [...] // Команды из пункта 3
        }
    ]
}
```

Клиент сортирует все команды каждого таска по timestamp и выполняет их (соответственно просто отрисовывая каждую задачу)


# В итоге:

Для всех действия, которые работают с журналом у нас одинаковая схема ответа/запроса. Это упростит расширение системы в дальнейшем и позволит писать плагины для системы в будущем, не трогая основной код клиента.